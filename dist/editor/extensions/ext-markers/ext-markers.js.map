{"version":3,"file":"ext-markers.js","sources":["../../../../src/editor/extensions/ext-markers/ext-markers.js"],"sourcesContent":["/**\r\n * @file ext-markers.js\r\n *\r\n * @license Apache-2.0\r\n *\r\n * @copyright 2010 Will Schleter based on ext-arrows.js by Copyright(c) 2010 Alexis Deveria\r\n * @copyright 2021 OptimistikSAS\r\n *\r\n * This extension provides for the addition of markers to the either end\r\n * or the middle of a line, polyline, path, polygon.\r\n *\r\n * Markers are graphics\r\n *\r\n * to simplify the coding and make the implementation as robust as possible,\r\n * markers are not shared - every object has its own set of markers.\r\n * this relationship is maintained by a naming convention between the\r\n * ids of the markers and the ids of the object\r\n *\r\n * The following restrictions exist for simplicty of use and programming\r\n *    objects and their markers to have the same color\r\n *    marker size is fixed\r\n *    an application specific attribute - se_type - is added to each marker element\r\n *        to store the type of marker\r\n *\r\n * @todo\r\n *    remove some of the restrictions above\r\n *\r\n*/\r\n\r\nexport default {\r\n  name: 'markers',\r\n  async init () {\r\n    const svgEditor = this\r\n    const { svgCanvas } = svgEditor\r\n    const { BatchCommand, RemoveElementCommand, InsertElementCommand } = svgCanvas.history\r\n    const { $id, addSVGElementsFromJson: addElem } = svgCanvas\r\n    const mtypes = ['start', 'mid', 'end']\r\n    const markerElems = ['line', 'path', 'polyline', 'polygon']\r\n\r\n    // note - to add additional marker types add them below with a unique id\r\n    // and add the associated icon(s) to marker-icons.svg\r\n    // the geometry is normalized to a 100x100 box with the origin at lower left\r\n    // Safari did not like negative values for low left of viewBox\r\n    // remember that the coordinate system has +y downward\r\n    const markerTypes = {\r\n      nomarker: {},\r\n      leftarrow:\r\n        { element: 'path', attr: { d: 'M0,50 L100,90 L70,50 L100,10 Z' } },\r\n      rightarrow:\r\n        { element: 'path', attr: { d: 'M100,50 L0,90 L30,50 L0,10 Z' } },\r\n      box:\r\n        { element: 'path', attr: { d: 'M20,20 L20,80 L80,80 L80,20 Z' } },\r\n      mcircle:\r\n        { element: 'circle', attr: { r: 30, cx: 50, cy: 50 } }\r\n    };\r\n\r\n    // duplicate shapes to support unfilled (open) marker types with an _o suffix\r\n    ['leftarrow', 'rightarrow', 'box', 'mcircle'].forEach((v) => {\r\n      markerTypes[v + '_o'] = markerTypes[v]\r\n    })\r\n\r\n    /**\r\n    * @param {Element} elem - A graphic element will have an attribute like marker-start\r\n    * @param {\"marker-start\"|\"marker-mid\"|\"marker-end\"} attr\r\n    * @returns {Element} The marker element that is linked to the graphic element\r\n    */\r\n    const getLinked = (elem, attr) => {\r\n      const str = elem.getAttribute(attr)\r\n      if (!str) { return null }\r\n      const m = str.match(/\\(#(.*)\\)/)\r\n      // \"url(#mkr_end_svg_1)\" would give m[1] = \"mkr_end_svg_1\"\r\n      if (!m || m.length !== 2) {\r\n        return null\r\n      }\r\n      return svgCanvas.getElement(m[1])\r\n    }\r\n\r\n    /**\r\n     * Toggles context tool panel off/on.\r\n     * @param {boolean} on\r\n     * @returns {void}\r\n    */\r\n    const showPanel = (on, elem) => {\r\n      $id('marker_panel').style.display = (on) ? 'block' : 'none'\r\n      if (on && elem) {\r\n        mtypes.forEach((pos) => {\r\n          const marker = getLinked(elem, 'marker-' + pos)\r\n          if (marker?.attributes?.se_type) {\r\n            $id(`${pos}_marker_list_opts`).setAttribute('value', marker.attributes.se_type.value)\r\n          } else {\r\n            $id(`${pos}_marker_list_opts`).setAttribute('value', 'nomarker')\r\n          }\r\n        })\r\n      }\r\n    }\r\n\r\n    /**\r\n    * @param {string} id\r\n    * @param {\"\"|\"nomarker\"|\"nomarker\"|\"leftarrow\"|\"rightarrow\"|\"textmarker\"|\"forwardslash\"|\"reverseslash\"|\"verticalslash\"|\"box\"|\"star\"|\"xmark\"|\"triangle\"|\"mcircle\"} seType\r\n    * @returns {SVGMarkerElement}\r\n    */\r\n    const addMarker = (id, seType) => {\r\n      const selElems = svgCanvas.getSelectedElements()\r\n      let marker = svgCanvas.getElement(id)\r\n      if (marker) { return undefined }\r\n      if (seType === '' || seType === 'nomarker') { return undefined }\r\n      const el = selElems[0]\r\n      const color = el.getAttribute('stroke')\r\n      const strokeWidth = 10\r\n      const refX = 50\r\n      const refY = 50\r\n      const viewBox = '0 0 100 100'\r\n      const markerWidth = 5\r\n      const markerHeight = 5\r\n\r\n      if (!markerTypes[seType]) {\r\n        console.error(`unknown marker type: ${seType}`)\r\n        return undefined\r\n      }\r\n\r\n      // create a generic marker\r\n      marker = addElem({\r\n        element: 'marker',\r\n        attr: {\r\n          id,\r\n          markerUnits: 'strokeWidth',\r\n          orient: 'auto',\r\n          style: 'pointer-events:none',\r\n          se_type: seType\r\n        }\r\n      })\r\n\r\n      const mel = addElem(markerTypes[seType])\r\n      const fillcolor = (seType.substr(-2) === '_o')\r\n        ? 'none'\r\n        : color\r\n\r\n      mel.setAttribute('fill', fillcolor)\r\n      mel.setAttribute('stroke', color)\r\n      mel.setAttribute('stroke-width', strokeWidth)\r\n      marker.append(mel)\r\n\r\n      marker.setAttribute('viewBox', viewBox)\r\n      marker.setAttribute('markerWidth', markerWidth)\r\n      marker.setAttribute('markerHeight', markerHeight)\r\n      marker.setAttribute('refX', refX)\r\n      marker.setAttribute('refY', refY)\r\n      svgCanvas.findDefs().append(marker)\r\n\r\n      return marker\r\n    }\r\n\r\n    /**\r\n    * @param {Element} elem\r\n    * @returns {SVGPolylineElement}\r\n    */\r\n    const convertline = (elem) => {\r\n      // this routine came from the connectors extension\r\n      // it is needed because midpoint markers don't work with line elements\r\n      if (elem.tagName !== 'line') { return elem }\r\n\r\n      // Convert to polyline to accept mid-arrow\r\n      const x1 = Number(elem.getAttribute('x1'))\r\n      const x2 = Number(elem.getAttribute('x2'))\r\n      const y1 = Number(elem.getAttribute('y1'))\r\n      const y2 = Number(elem.getAttribute('y2'))\r\n      const { id } = elem\r\n\r\n      const midPt = (' ' + ((x1 + x2) / 2) + ',' + ((y1 + y2) / 2) + ' ')\r\n      const pline = addElem({\r\n        element: 'polyline',\r\n        attr: {\r\n          points: (x1 + ',' + y1 + midPt + x2 + ',' + y2),\r\n          stroke: elem.getAttribute('stroke'),\r\n          'stroke-width': elem.getAttribute('stroke-width'),\r\n          fill: 'none',\r\n          opacity: elem.getAttribute('opacity') || 1\r\n        }\r\n      })\r\n      mtypes.forEach((pos) => { // get any existing marker definitions\r\n        const nam = 'marker-' + pos\r\n        const m = elem.getAttribute(nam)\r\n        if (m) { pline.setAttribute(nam, elem.getAttribute(nam)) }\r\n      })\r\n\r\n      const batchCmd = new BatchCommand()\r\n      batchCmd.addSubCommand(new RemoveElementCommand(elem, elem.parentNode))\r\n      batchCmd.addSubCommand(new InsertElementCommand(pline))\r\n\r\n      elem.insertAdjacentElement('afterend', pline)\r\n      elem.remove()\r\n      svgCanvas.clearSelection()\r\n      pline.id = id\r\n      svgCanvas.addToSelection([pline])\r\n      svgCanvas.addCommandToHistory(batchCmd)\r\n      return pline\r\n    }\r\n\r\n    /**\r\n    *\r\n    * @returns {void}\r\n    */\r\n    const setMarker = (pos, markerType) => {\r\n      const selElems = svgCanvas.getSelectedElements()\r\n      if (selElems.length === 0) return\r\n      const markerName = 'marker-' + pos\r\n      const el = selElems[0]\r\n      const marker = getLinked(el, markerName)\r\n      if (marker) { marker.remove() }\r\n      el.removeAttribute(markerName)\r\n      let val = markerType\r\n      if (val === '') { val = 'nomarker' }\r\n      if (val === 'nomarker') {\r\n        svgCanvas.call('changed', selElems)\r\n        return\r\n      }\r\n      // Set marker on element\r\n      const id = 'mkr_' + pos + '_' + el.id\r\n      addMarker(id, val)\r\n      svgCanvas.changeSelectedAttribute(markerName, 'url(#' + id + ')')\r\n      if (el.tagName === 'line' && pos === 'mid') {\r\n        convertline(el)\r\n      }\r\n      svgCanvas.call('changed', selElems)\r\n    }\r\n\r\n    /**\r\n     * Called when the main system modifies an object. This routine changes\r\n     *   the associated markers to be the same color.\r\n     * @param {Element} elem\r\n     * @returns {void}\r\n    */\r\n    const colorChanged = (elem) => {\r\n      const color = elem.getAttribute('stroke')\r\n\r\n      mtypes.forEach((pos) => {\r\n        const marker = getLinked(elem, 'marker-' + pos)\r\n        if (!marker) { return }\r\n        if (!marker.attributes.se_type) { return } // not created by this extension\r\n        const ch = marker.lastElementChild\r\n        if (!ch) { return }\r\n        const curfill = ch.getAttribute('fill')\r\n        const curstroke = ch.getAttribute('stroke')\r\n        if (curfill && curfill !== 'none') { ch.setAttribute('fill', color) }\r\n        if (curstroke && curstroke !== 'none') { ch.setAttribute('stroke', color) }\r\n      })\r\n    }\r\n\r\n    /**\r\n    * Called when the main system creates or modifies an object.\r\n    * Its primary purpose is to create new markers for cloned objects.\r\n    * @param {Element} el\r\n    * @returns {void}\r\n    */\r\n    const updateReferences = (el) => {\r\n      const selElems = svgCanvas.getSelectedElements()\r\n      mtypes.forEach((pos) => {\r\n        const markerName = 'marker-' + pos\r\n        const marker = getLinked(el, markerName)\r\n        if (!marker || !marker.attributes.se_type) { return } // not created by this extension\r\n        const url = el.getAttribute(markerName)\r\n        if (url) {\r\n          const len = el.id.length\r\n          const linkid = url.substr(-len - 1, len)\r\n          if (el.id !== linkid) {\r\n            const newMarkerId = 'mkr_' + pos + '_' + el.id\r\n            addMarker(newMarkerId, marker.attributes.se_type.value)\r\n            svgCanvas.changeSelectedAttribute(markerName, 'url(#' + newMarkerId + ')')\r\n            svgCanvas.call('changed', selElems)\r\n          }\r\n        }\r\n      })\r\n    }\r\n\r\n    return {\r\n      name: svgEditor.i18next.t(`${name}:name`),\r\n      // The callback should be used to load the DOM with the appropriate UI items\r\n      callback () {\r\n        // Add the context panel and its handler(s)\r\n        const panelTemplate = document.createElement('template')\r\n        // create the marker panel\r\n        let innerHTML = '<div id=\"marker_panel\">'\r\n        mtypes.forEach((pos) => {\r\n          innerHTML += `<se-list id=\"${pos}_marker_list_opts\" title=\"tools.${pos}_marker_list_opts\" label=\"\" width=\"22px\" height=\"22px\">`\r\n          Object.entries(markerTypes).forEach(([marker, _mkr]) => {\r\n            innerHTML += `<se-list-item id=\"mkr_${pos}_${marker}\" value=\"${marker}\" title=\"tools.mkr_${marker}\" src=\"${marker}.svg\" img-height=\"22px\"></se-list-item>`\r\n          })\r\n          innerHTML += '</se-list>'\r\n        })\r\n        innerHTML += '</div>'\r\n        panelTemplate.innerHTML = innerHTML\r\n        $id('tools_top').appendChild(panelTemplate.content.cloneNode(true))\r\n        // don't display the panels on start\r\n        showPanel(false)\r\n        mtypes.forEach((pos) => {\r\n          $id(`${pos}_marker_list_opts`).addEventListener('change', (evt) => {\r\n            setMarker(pos, evt.detail.value)\r\n          })\r\n        })\r\n      },\r\n      selectedChanged (opts) {\r\n        // Use this to update the current selected elements\r\n        if (opts.elems.length === 0) showPanel(false)\r\n        opts.elems.forEach((elem) => {\r\n          if (elem && markerElems.includes(elem.tagName)) {\r\n            if (opts.selectedElement && !opts.multiselected) {\r\n              showPanel(true, elem)\r\n            } else {\r\n              showPanel(false)\r\n            }\r\n          } else {\r\n            showPanel(false)\r\n          }\r\n        })\r\n      },\r\n      elementChanged (opts) {\r\n        const elem = opts.elems[0]\r\n        if (elem && (\r\n          elem.getAttribute('marker-start') ||\r\n          elem.getAttribute('marker-mid') ||\r\n          elem.getAttribute('marker-end')\r\n        )) {\r\n          colorChanged(elem)\r\n          updateReferences(elem)\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n"],"names":["name","svgCanvas","this","BatchCommand","RemoveElementCommand","InsertElementCommand","history","$id","addSVGElementsFromJson","addElem","mtypes","markerElems","markerTypes","nomarker","leftarrow","element","attr","d","rightarrow","box","mcircle","r","cx","cy","forEach","v","getLinked","elem","str","getAttribute","m","match","length","getElement","showPanel","on","style","display","pos","marker","attributes","_marker$attributes","se_type","setAttribute","value","addMarker","id","seType","selElems","getSelectedElements","color","console","error","markerUnits","orient","mel","fillcolor","substr","append","findDefs","setMarker","markerType","markerName","el","remove","removeAttribute","val","call","changeSelectedAttribute","tagName","x1","Number","x2","y1","y2","pline","points","stroke","fill","opacity","nam","batchCmd","addSubCommand","parentNode","insertAdjacentElement","clearSelection","addToSelection","addCommandToHistory","convertline","i18next","t","callback","panelTemplate","document","createElement","innerHTML","Object","entries","_ref","_mkr","appendChild","content","cloneNode","addEventListener","evt","detail","selectedChanged","opts","elems","includes","selectedElement","multiselected","elementChanged","ch","lastElementChild","curfill","curstroke","colorChanged","url","len","linkid","newMarkerId","updateReferences"],"mappings":"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"}